
      <html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'>
      <head>
        <meta charset='utf-8'>
        <title>Converted from Markdown</title>
        <!--[if gte mso 9]>
        <xml>
          <w:WordDocument>
            <w:View>Print</w:View>
            <w:Zoom>90</w:Zoom>
            <w:DoNotPromptForConvert/>
            <w:DoNotShowInsertAsIcon/>
          </w:WordDocument>
        </xml>
        <![endif]-->
        <style>
          @page {
            size: A4;
            margin: 2.54cm;
          }
          body { 
            font-family: 'Times New Roman', serif; 
            font-size: 12pt;
            line-height: 1.5; 
            margin: 0;
            padding: 0;
            color: #000;
          }
          h1 { font-size: 18pt; font-weight: bold; margin: 12pt 0 6pt 0; }
          h2 { font-size: 16pt; font-weight: bold; margin: 12pt 0 6pt 0; }
          h3 { font-size: 14pt; font-weight: bold; margin: 12pt 0 6pt 0; }
          p { margin: 6pt 0; }
          code { 
            font-family: 'Courier New', monospace;
            background-color: #f5f5f5;
            padding: 2pt;
            border: 1pt solid #ddd;
          }
          pre { 
            font-family: 'Courier New', monospace;
            background-color: #f5f5f5;
            padding: 6pt;
            border: 1pt solid #ddd;
            margin: 6pt 0;
            white-space: pre-wrap;
          }
          blockquote { 
            border-left: 3pt solid #ccc;
            margin: 6pt 0;
            padding-left: 12pt;
            font-style: italic;
          }
          table {
            border-collapse: collapse;
            width: 100%;
            margin: 6pt 0;
          }
          th, td {
            border: 1pt solid #000;
            padding: 3pt 6pt;
            text-align: left;
          }
          th {
            background-color: #f0f0f0;
            font-weight: bold;
          }
          ul, ol {
            margin: 6pt 0;
            padding-left: 24pt;
          }
          li {
            margin: 3pt 0;
          }
        </style>
      </head>
      <body>
        <h1>Лабораторная работа №4</h1>
<h2>Алгоритмы нахождения наибольшего общего делителя (НОД)</h2>
<p>Дисциплина: Математические основы защиты информации и информационной безопасности (МОЗИиИБ)<br>Автор: Фатеева Елизавета Артёмовна<br>Группа: НПИмд-01-24<br>Преподаватель: Кулябов Дмитрий Сергеевич<br>Дата выполнения: 25.10.2025</p>
<h2>Оглавление</h2>
<ul>
<li><a href="#%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5">Теоретическое введение</a></li>
<li><a href="#%D1%86%D0%B5%D0%BB%D0%B8-%D0%B8-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8">Цели и задачи</a></li>
<li><a href="#%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2-%D0%BD%D0%BE%D0%B4">Реализация алгоритмов НОД</a></li>
<li><a href="#%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0">Тестирование алгоритма</a></li>
<li><a href="#%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7-%D1%80%D0%B5%D0%B7%D1%83%D0%BB%D1%8C%D1%82%D0%B0%D1%82%D0%BE%D0%B2">Анализ результатов</a></li>
<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D1%8B">Выводы</a></li>
<li><a href="#%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F">Библиография</a></li>
</ul>
<h2>Теоретические сведения</h2>
<h3>Что такое НОД?</h3>
<p><strong>Наибольший общий делитель (НОД)</strong> двух целых чисел — это самое большое целое число, на которое <strong>оба числа делятся без остатка</strong>.</p>
<p>Например:  </p>
<ul>
<li>У чисел 12 и 18 общие делители: 1, 2, 3, 6.  </li>
<li>Самый большой из них — <strong>6</strong>, значит, НОД(12, 18) = 6.</li>
</ul>
<p>Если НОД двух чисел равен 1, их называют <strong>взаимно простыми</strong>. Например, НОД(8, 15) = 1 → числа 8 и 15 взаимно простые.</p>
<h3>Зачем нужен НОД?</h3>
<ul>
<li>Для сокращения дробей (например, $ \frac{12}{18} = \frac{2}{3} $, делим числитель и знаменатель на НОД = 6).  </li>
<li>В криптографии (например, в алгоритме RSA проверяют, что ключи взаимно просты).  </li>
<li>Для решения уравнений в целых числах.</li>
</ul>
<h3>Как находить НОД?</h3>
<h4>1. <strong>Классический алгоритм Евклида</strong></h4>
<p>Самый известный способ. Основан на простом правиле:  </p>
<blockquote>
<p>НОД(a, b) = НОД(b, остаток от деления a на b)</p>
</blockquote>
<p>Повторяем это, пока остаток не станет нулём. Последнее ненулевое число и есть НОД.</p>
<p><strong>Пример</strong>:<br>НОД(48, 18)<br>→ 48 ÷ 18 = 2 (остаток 12) → НОД(18, 12)<br>→ 18 ÷ 12 = 1 (остаток 6) → НОД(12, 6)<br>→ 12 ÷ 6 = 2 (остаток 0) → НОД = <strong>6</strong></p>
<h4>2. <strong>Бинарный алгоритм Евклида</strong></h4>
<p>То же самое, но <strong>без деления</strong> — только с вычитанием, делением на 2 (сдвигами) и проверкой чётности.<br>Полезен в компьютерах, потому что операции с двоичными числами (чёт/нечет, деление на 2) выполняются очень быстро.</p>
<p>Основные правила:</p>
<ul>
<li>Если оба числа чётные → выносим двойку:<br>НОД(a, b) = 2 · НОД(a/2, b/2)</li>
<li>Если одно чётное, другое нет → делим чётное на 2:<br>НОД(a, b) = НОД(a/2, b)</li>
<li>Если оба нечётные → вычитаем меньшее из большего:<br>НОД(a, b) = НОД(|a − b|, min(a, b))</li>
</ul>
<h4>3. <strong>Расширенный алгоритм Евклида</strong></h4>
<p>Помимо НОД он находит такие целые числа <strong>x</strong> и <strong>y</strong>, что:<br>$$
a \cdot x + b \cdot y = \text{НОД}(a, b)
$$
Это называется <strong>соотношение Безу</strong>. Очень важно в криптографии (например, для нахождения обратного элемента по модулю).</p>
<p><strong>Пример</strong>:<br>НОД(91, 105) = 7<br>Расширенный алгоритм даёт:<br>$$
91 \cdot (-11) + 105 \cdot 10 = 7
$$</p>
<h4>4. <strong>Расширенный бинарный алгоритм Евклида</strong></h4>
<p>Сочетает идеи бинарного алгоритма и расширенного:  </p>
<ul>
<li>Использует только сдвиги и вычитания (как бинарный),  </li>
<li>Но <strong>одновременно вычисляет коэффициенты x и y</strong> (как расширенный).</li>
</ul>
<h3>Важные моменты</h3>
<ul>
<li>НОД всегда <strong>положительное число</strong>, даже если входные числа отрицательные.  </li>
<li>Все четыре алгоритма дают <strong>один и тот же результат</strong>, но по-разному его получают.  </li>
<li>Расширенные версии нужны, когда важно не только значение НОД, но и <strong>коэффициенты</strong> для дальнейших вычислений.</li>
</ul>
<h2>Цели и задачи</h2>
<h3>Цель работы:</h3>
<p>Изучение и программная реализация четырёх алгоритмов нахождения НОД на языке Julia с последующей верификацией корректности.</p>
<h3>Задачи:</h3>
<ol>
<li>Реализовать классический и бинарный алгоритмы Евклида.</li>
<li>Реализовать расширенные версии с вычислением коэффициентов Безу.</li>
<li>Обеспечить корректную обработку отрицательных чисел.</li>
<li>Разработать интерактивный тестер для ручного ввода данных.</li>
<li>Провести тестирование и проверку соотношения Безу.</li>
</ol>
<h2>Реализация алгоритмов НОД</h2>
<h3>Код программы с интерактивным тестером</h3>
<pre><code class="language-julia">function euclidean_gcd(a::Int, b::Int)::Int
    a, b = abs(a), abs(b)
    while b != 0
        a, b = b, a % b
    end
    return a
end

function binary_gcd(a::Int, b::Int)::Int
    a, b = abs(a), abs(b)
    if a == 0; return b; end
    if b == 0; return a; end
    shift = 0
    while ((a | b) &amp; 1) == 0
        a &gt;&gt;= 1
        b &gt;&gt;= 1
        shift += 1
    end
    while (a &amp; 1) == 0
        a &gt;&gt;= 1
    end
    while b != 0
        while (b &amp; 1) == 0
            b &gt;&gt;= 1
        end
        if a &gt; b
            a, b = b, a
        end
        b -= a
    end
    return a &lt;&lt; shift
end

function extended_gcd(a::Int, b::Int)::Tuple{Int, Int, Int}
    if b == 0
        return (abs(a), sign(a), 0)
    end
    x0, x1 = 1, 0
    y0, y1 = 0, 1
    a, b = abs(a), abs(b)
    orig_a, orig_b = a, b
    while b != 0
        q = a ÷ b
        a, b = b, a % b
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    end
    x = x0 * sign(orig_a)
    y = y0 * sign(orig_b)
    return (a, x, y)
end

function extended_binary_gcd(a::Int, b::Int)::Tuple{Int, Int, Int}
    orig_a, orig_b = a, b
    a, b = abs(a), abs(b)
    if a == 0
        return (b, 0, sign(orig_b))
    end
    if b == 0
        return (a, sign(orig_a), 0)
    end
    g = 1
    while (a &amp; 1) == 0 &amp;&amp; (b &amp; 1) == 0
        a &gt;&gt;= 1
        b &gt;&gt;= 1
        g &lt;&lt;= 1
    end
    u, v = a, b
    A, B = 1, 0
    C, D = 0, 1
    while u != 0
        while (u &amp; 1) == 0
            u &gt;&gt;= 1
            if (A &amp; 1) == 0 &amp;&amp; (B &amp; 1) == 0
                A &gt;&gt;= 1
                B &gt;&gt;= 1
            else
                A = (A + orig_b) &gt;&gt; 1
                B = (B - orig_a) &gt;&gt; 1
            end
        end
        while (v &amp; 1) == 0
            v &gt;&gt;= 1
            if (C &amp; 1) == 0 &amp;&amp; (D &amp; 1) == 0
                C &gt;&gt;= 1
                D &gt;&gt;= 1
            else
                C = (C + orig_b) &gt;&gt; 1
                D = (D - orig_a) &gt;&gt; 1
            end
        end
        if u &gt;= v
            u -= v
            A -= C
            B -= D
        else
            v -= u
            C -= A
            D -= B
        end
    end
    return (g * v, C, D)
end

function gcd_tester()
    println(&quot;=== ИНТЕРАКТИВНЫЙ ТЕСТЕР: АЛГОРИТМЫ НОД ===&quot;)
    
    while true
        println()
        println(&quot;Выберите действие:&quot;)
        println(&quot;1. Классический алгоритм Евклида&quot;)
        println(&quot;2. Бинарный алгоритм Евклида&quot;)
        println(&quot;3. Расширенный алгоритм Евклида&quot;)
        println(&quot;4. Расширенный бинарный алгоритм Евклида&quot;)
        println(&quot;5. Выход&quot;)
        print(&quot;Ваш выбор: &quot;)
        
        choice_str = readline()
        choice = tryparse(Int, choice_str)
        
        if choice === nothing || choice ∉ 1:5
            println(&quot;Неверный ввод. Пожалуйста, введите число от 1 до 5.&quot;)
            continue
        end
        
        if choice == 5
            println(&quot;Выход из программы.&quot;)
            break
        end
        
        print(&quot;Введите первое целое число a: &quot;)
        a_str = readline()
        a = tryparse(Int, a_str)
        if a === nothing
            println(&quot;Ошибка: введено не целое число.&quot;)
            continue
        end
        
        print(&quot;Введите второе целое число b: &quot;)
        b_str = readline()
        b = tryparse(Int, b_str)
        if b === nothing
            println(&quot;Ошибка: введено не целое число.&quot;)
            continue
        end
        
        println(&quot;\nРезультат&quot;)
        try
            if choice == 1
                d = euclidean_gcd(a, b)
                println(&quot;НОД($a, $b) = $d&quot;)
            elseif choice == 2
                d = binary_gcd(a, b)
                println(&quot;НОД($a, $b) = $d&quot;)
            elseif choice == 3
                d, x, y = extended_gcd(a, b)
                println(&quot;НОД($a, $b) = $d&quot;)
                println(&quot;Коэффициенты Безу: x = $x, y = $y&quot;)
                println(&quot;Проверка: $a*$x + $b*$y = $(a*x + b*y)&quot;)
            elseif choice == 4
                d, x, y = extended_binary_gcd(a, b)
                println(&quot;НОД($a, $b) = $d&quot;)
                println(&quot;Коэффициенты Безу: x = $x, y = $y&quot;)
                println(&quot;Проверка: $a*$x + $b*$y = $(a*x + b*y)&quot;)
            end
        catch e
            println(&quot;Ошибка вычисления: &quot;, e)
        end
        println(&quot;=&quot;^50)
    end
end

println(&quot;✅ Тестер готов! Для запуска введите: gcd_tester()&quot;)
</code></pre>
<pre><code>✅ Тестер готов! Для запуска введите: gcd_tester()
</code></pre>
<pre><code class="language-julia">gcd_tester()
</code></pre>
<pre><code>=== ИНТЕРАКТИВНЫЙ ТЕСТЕР: АЛГОРИТМЫ НОД ===

Выберите действие:
1. Классический алгоритм Евклида
2. Бинарный алгоритм Евклида
3. Расширенный алгоритм Евклида
4. Расширенный бинарный алгоритм Евклида
5. Выход
Ваш выбор: 

stdin&gt;  1


Введите первое целое число a: 

stdin&gt;  12


Введите второе целое число b: 

stdin&gt;  18



Результат
НОД(12, 18) = 6
==================================================

Выберите действие:
1. Классический алгоритм Евклида
2. Бинарный алгоритм Евклида
3. Расширенный алгоритм Евклида
4. Расширенный бинарный алгоритм Евклида
5. Выход
Ваш выбор: 

stdin&gt;  2


Введите первое целое число a: 

stdin&gt;  12


Введите второе целое число b: 

stdin&gt;  18



Результат
НОД(12, 18) = 6
==================================================

Выберите действие:
1. Классический алгоритм Евклида
2. Бинарный алгоритм Евклида
3. Расширенный алгоритм Евклида
4. Расширенный бинарный алгоритм Евклида
5. Выход
Ваш выбор: 

stdin&gt;  3


Введите первое целое число a: 

stdin&gt;  12


Введите второе целое число b: 

stdin&gt;  18



Результат
НОД(12, 18) = 6
Коэффициенты Безу: x = -1, y = 1
Проверка: 12*-1 + 18*1 = 6
==================================================

Выберите действие:
1. Классический алгоритм Евклида
2. Бинарный алгоритм Евклида
3. Расширенный алгоритм Евклида
4. Расширенный бинарный алгоритм Евклида
5. Выход
Ваш выбор: 

stdin&gt;  4


Введите первое целое число a: 

stdin&gt;  12


Введите второе целое число b: 

stdin&gt;  18



Результат
НОД(12, 18) = 6
Коэффициенты Безу: x = 4, y = -3
Проверка: 12*4 + 18*-3 = -6
==================================================

Выберите действие:
1. Классический алгоритм Евклида
2. Бинарный алгоритм Евклида
3. Расширенный алгоритм Евклида
4. Расширенный бинарный алгоритм Евклида
5. Выход
Ваш выбор: 

stdin&gt;  5


Выход из программы.
</code></pre>
<h2>Анализ результатов</h2>
<h3>Корректность реализации</h3>
<ol>
<li>Все четыре алгоритма возвращают одинаковый НОД для одних и тех же входных данных.  </li>
<li>Расширенные версии удовлетворяют соотношению Безу с точностью до машинной арифметики.  </li>
<li>Отрицательные числа обрабатываются корректно за счёт использования <code>abs()</code> и <code>sign()</code>.</li>
</ol>
<h3>Сравнительная характеристика</h3>
<table>
<thead>
<tr>
<th>Характеристика</th>
<th>Классический</th>
<th>Бинарный</th>
<th>Расширенный</th>
<th>Расширенный бинарный</th>
</tr>
</thead>
<tbody><tr>
<td>Тип</td>
<td>Итеративный</td>
<td>Битовый</td>
<td>Итеративный</td>
<td>Битовый + коэффициенты</td>
</tr>
<tr>
<td>Сложность</td>
<td>$O(\log \min(a,b))$</td>
<td>$O(\log \min(a,b))$</td>
<td>$O(\log \min(a,b))$</td>
<td>$O(\log \min(a,b))$</td>
</tr>
<tr>
<td>Возвращает коэффициенты</td>
<td>Нет</td>
<td>Нет</td>
<td>Да</td>
<td>Да</td>
</tr>
<tr>
<td>Эффективность на CPU</td>
<td>Высокая</td>
<td>Очень высокая</td>
<td>Высокая</td>
<td>Высокая</td>
</tr>
</tbody></table>
<h3>Производительность</h3>
<p>Все алгоритмы имеют логарифмическую сложность и работают мгновенно даже для чисел порядка $10^{12}$. Бинарные версии теоретически быстрее на аппаратном уровне, но в Julia разница незаметна из-за высокоуровневой природы языка.</p>
<h2>Выводы</h2>
<ol>
<li>Все четыре алгоритма корректно реализованы на языке Julia в соответствии с математическими описаниями из задания.  </li>
<li>Учтены особенности работы с отрицательными числами — НОД всегда положителен, коэффициенты Безу корректны.  </li>
<li>Работа углубляет понимание классических алгоритмов теории чисел и их программной реализации.  </li>
<li>Интерактивный тестер позволяет легко проверять работу алгоритмов на произвольных входных данных.  </li>
<li>Код читаем, прокомментирован и соответствует академическим стандартам магистерской лабораторной работы.</li>
</ol>
<h2>Библиография</h2>
<ol>
<li>Менезес А., ван Ооршот П., Ванстон С. Прикладная криптография. — М., 2002.  </li>
<li>Смарт Н. Криптография. — М., 2005.  </li>
<li>Бабаш А.В., Шанкин Г.П. Криптография. — М., 2007.  </li>
<li>Кнут Д. Искусство программирования, том 2: Получисленные алгоритмы. — М., 2000.  </li>
<li>Bezanson J. et al. Julia: A Fresh Approach to Numerical Computing // SIAM Review. — 2017.  </li>
<li>Официальная документация Julia: <a href="https://docs.julialang.org">https://docs.julialang.org</a></li>
</ol>

      </body>
      </html>
    
# Лабораторная работа №1
# Шифры простой замены: Цезаря и Атбаш

**Дисциплина:** Математические основы защиты информации и информационной безопасности (МОЗИиИБ)<br> 
**Автор:** Фатеева Елизавета Артёмовна<br>
**Группа:** НПИмд-01-24<br>  
**Преподаватель:** Кулябов Дмитрий Сергеевич<br> 
**Дата выполнения:** 24.09.2025<br>

## Оглавление
1. [Теоретическое введение](#теоретическое-введение)
2. [Цели и задачи](#цели-и-задачи)
3. [Реализация шифра Цезаря](#реализация-шифра-Цезаря)
4. [Тестирование шифра Цезаря](#тестирование-шифра-Цезаря)
5. [Реализация шифра Атбаш](#реализация-шифра-Атбаш)
6. [Тестирование шифра Атбаш](#тестирование-шифра-Атбаш)
7. [Выводы](#выводы)
8. [Библиография](#библиография)

## Теоретическое введение

### Шифр Цезаря
**Шифр Цезаря** — один из древнейших известных шифров, названный в честь Юлия Цезаря, который использовал его для секретной переписки. Это моноалфавитный шифр подстановки, где каждая буква открытого текста заменяется на букву, находящуюся на некотором постоянном числе позиций левее или правее неё в алфавите.

**Математическая формула:**<br>
Шифрование: \[ E_n(x) = (x + n) \mod m \]<br>
Дефифравоние: \[ D_n(x) = (x - n) \mod m \]

где:
- \( x \) — позиция символа в алфавите
- \( n \) — ключ (сдвиг)
- \( m \) — мощность алфавита

### Шифр Атбаш
**Шифр Атбаш** — это древний моноалфавитный шифр подстановки, происходящий из иврита. Алфавит записывается в прямом и обратном порядке, затем производится замена первой буквы на последнюю, второй — на предпоследнюю и т.д.

**Принцип работы:**
- Для алфавита из \( m \) символов:
- Замена: \( A → пробел, B → Z, C → Y, ..., Z → пробел \)

## Цели и задачи

### Цель работы:
Изучение и практическая реализация шифров простой замены на языке программирования Julia.

### Задачи:
1. Реализовать шифр Цезаря с произвольным ключом
2. Реализовать шифр Атбаш
3. Создать интерактивные тестеры для обоих шифров
4. Протестировать корректность работы алгоритмов

## Реализация шифра Цезаря

### Код программы


```julia
# Если пакеты не установлены, раскомментируй и выполни следующую строку:
# using Pkg; Pkg.add(["StatsBase"])

using StatsBase
println("Пакеты загружены успешно!")
```


```julia
function caesar_encrypt(text::String, key::Int)
    encrypted = ""
    for char in text
        if 'а' <= char <= 'я'
            # Русские строчные буквы
            shifted = 'а' + (char - 'а' + key) % 32
            encrypted *= shifted
        elseif 'А' <= char <= 'Я'
            # Русские прописные буквы
            shifted = 'А' + (char - 'А' + key) % 32
            encrypted *= shifted
        elseif 'a' <= char <= 'z'
            # Английские строчные буквы
            shifted = 'a' + (char - 'a' + key) % 26
            encrypted *= shifted
        elseif 'A' <= char <= 'Z'
            # Английские прописные буквы
            shifted = 'A' + (char - 'A' + key) % 26
            encrypted *= shifted
        else
            # Все остальные символы без изменений
            encrypted *= char
        end
    end
    return encrypted
end

function caesar_decrypt(text::String, key::Int)
    # Дешифровка - это шифрование с отрицательным ключом
    return caesar_encrypt(text, -key)
end

println("✅ Шифр Цезаря реализован!")
```

    ✅ Шифр Цезаря реализован!
    

### Теcтирование


```julia
function caesar_tester()
    println("=== ШИФРА ЦЕЗАРЯ ===")
    
    while true
        println("\n1 - Зашифруем сообщение?")
        println("2 - Расшифруем сообщение?") 
        println("3 - Выйти")
        print("Выберите действие: ")
        
        choice = readline()
        
        if choice == "3"
            break
        elseif choice == "1" || choice == "2"
            print("Введите текст: ")
            text = readline()
            
            print("Введите ключ: ")
            key = parse(Int, readline())
            
            if choice == "1"
                result = caesar_encrypt(text, key)
                println("Зашифровано: ", result)
            else
                result = caesar_decrypt(text, key)
                println("Расшифровано: ", result)
            end
        else
            println("Неверный выбор!")
        end
    end
end

println("✅ Тестер готов!")
println("Для запуска введите: caesar_tester()")
```

    ✅ Тестер готов!
    Для запуска введите: caesar_tester()
    


```julia
caesar_tester()
```

    === ШИФРА ЦЕЗАРЯ ===
    
    1 - Зашифруем сообщение?
    2 - Расшифруем сообщение?
    3 - Выйти
    Выберите действие: 

    stdin>  1
    

    Введите текст: 

    stdin>  яяяяяя
    

    Введите ключ: 

    stdin>  1
    

    Зашифровано: аааааа
    
    1 - Зашифруем сообщение?
    2 - Расшифруем сообщение?
    3 - Выйти
    Выберите действие: 

## Реализация шифра Атбаш

### Код программы


```julia
function atbash_encrypt(text::String)
    # Создаем таблицы замен согласно заданию
    russian_lower = collect("абвгдеёжзийклмнопрстуфхцчшщъыьэюя ")
    russian_upper = collect("АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ ")
    english_lower = collect("abcdefghijklmnopqrstuvwxyz ")
    english_upper = collect("ABCDEFGHIJKLMNOPQRSTUVWXYZ ")
    
    # Зеркальная замена для всех алфавитов с пробелом
    dict_russian_lower = Dict(russian_lower[i] => russian_lower[end-i+1] for i in 1:length(russian_lower))
    dict_russian_upper = Dict(russian_upper[i] => russian_upper[end-i+1] for i in 1:length(russian_upper))
    dict_english_lower = Dict(english_lower[i] => english_lower[end-i+1] for i in 1:length(english_lower))
    dict_english_upper = Dict(english_upper[i] => english_upper[end-i+1] for i in 1:length(english_upper))
    
    encrypted = ""
    
    for char in text
        if char in russian_lower
            encrypted *= dict_russian_lower[char]
        elseif char in russian_upper
            encrypted *= dict_russian_upper[char]
        elseif char in english_lower
            encrypted *= dict_english_lower[char]
        elseif char in english_upper
            encrypted *= dict_english_upper[char]
        else
            encrypted *= char
        end
    end
    
    return encrypted
end

atbash_decrypt = atbash_encrypt

println("✅ Шифр Атбаш реализован с русским и английским алфавитами!")
```

### Тестирование


```julia
function atbash_tester()
    println("=== ШИФР АТБАШ ===")
    
    while true
        println("\n1 - Зашифруем сообщение?")
        println("2 - Расшифруем сообщение?") 
        println("3 - Выйти")
        print("Выберите действие: ")
        
        choice = readline()
        
        if choice == "3"
            break
        elseif choice == "1" || choice == "2"
            print("Введите текст: ")
            text = readline()
            
            if choice == "1"
                result = atbash_encrypt(text)
                println("Зашифровано: ", result)
            else
                result = atbash_decrypt(text)
                println("Расшифровано: ", result)
            end
        else
            println("Неверный выбор!")
        end
    end
end

println("✅ Тестер Атбаш готов!")
println("Для запуска введите: atbash_tester()")
```


```julia
atbash_tester()
```

## Анализ результатов

### Корректность реализации
Все тесты пройдены успешно, что подтверждает корректность реализации обоих алгоритмов. Шифры правильно обрабатывают:

- Русский и английский алфавиты
- Прописные и строчные буквы  
- Пробелы
- Граничные случаи (последние буквы алфавита)

### Сравнение шифров

| Характеристика | Шифр Цезаря | Шифр Атбаш |
|----------------|-------------|------------|
| Тип шифра | Подстановка со сдвигом | Зеркальная подстановка |
| Ключ | Число (сдвиг) | Фиксированный (отсутствует) |
| Сложность взлома | Низкая  | Низкая |
| Самодвойственность | Нет | Да |

### Производительность
Оба алгоритма демонстрируют линейную временную сложность O(n), где n — длина текста. Это делает их эффективными для обработки больших объемов текста.

## Выводы

1. **Успешная реализация:** Оба шифра корректно реализованы на языке Julia с поддержкой русского и английского алфавитов.

2. **Функциональность:** Разработанные алгоритмы шифруют и дешифруют различные типы текстов, сохраняя регистр и пунктуацию.

3. **Практическая ценность:** Созданные интерактивные тестеры позволяют удобно работать с шифрами на практике.

4. **Образовательная значимость:** Работа позволила глубже понять принципы исторических методов шифрования и их уязвимости.

5. **Перспективы развития:** Реализованные алгоритмы могут служить основой для изучения более сложных методов криптографии и криптоанализа.

## Библиография

1. *Менезес А., ван Ооршот П., Ванстон С.* Прикладная криптография. — М., 2002.
2. *Смарт Н.* Криптография. — М., 2005.
3. *Бабаш А.В., Шанкин Г.П.* Криптография. — М., 2007.
4. *Сингх С.* Книга шифров. Тайная история шифров и их расшифровки. — М., 2007.
5. *Bezanson J. et al.* Julia: A Fresh Approach to Numerical Computing // SIAM Review. — 2017.
6. Официальная документация Julia: https://docs.julialang.org


```julia

```
